// registers with the leader, send periodic heartbeats to leader
// waits for task assignments from leader
// on start for all vms except 1 (leader); go to this directory and run: go run main.go
package main

import (
	"context"
	"fmt"
	"log"
	"mp4/pkg/api"
	"mp4/pkg/hydfs/client"
	"net"
	"os"
	"os/exec"
	"strconv"
	"strings"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type workerServer struct {
	api.UnimplementedWorkerServiceServer
	workerID    string
	hydfsClient *client.Client
}

// Process lines with a given executable
func processWithExecutable(executable string, lines []string) []string {
	if executable == "" {
		log.Printf("Error: Executable is empty.")
		return nil
	}

	input := strings.Join(lines, "\n")
	parts := strings.Fields(executable)
	if len(parts) == 0 {
		log.Printf("Error: Executable command is invalid: %s", executable)
		return nil
	}

	cmd := exec.Command(parts[0], parts[1:]...)
	cmd.Stdin = strings.NewReader(input)

	output, err := cmd.Output()
	if err != nil {
		log.Printf("Error running %s: %v", executable, err)
		return nil
	}

	return strings.Split(strings.TrimSpace(string(output)), "\n")
}

func logState(hydfsClient *client.Client, taskID string, uids []string, results []string) error {
	logFile := fmt.Sprintf("task-%s-log", taskID)
	content := fmt.Sprintf("UIDs:%s\nResults:%s\n", strings.Join(uids, ","), strings.Join(results, "\n"))

	_, _ = hydfsClient.SendRequest(client.Request{
		Operation: client.APPEND,
		HyDFSFile: logFile,
		Content:   content,
	})
	return nil
}

// Handle task execution from leader
func (s *workerServer) ExecuteTask(ctx context.Context, taskData *api.TaskData) (*api.ExecutionResponse, error) {
	if taskData.Executable == "" {
		log.Printf("Error: Executable is empty for task %s", taskData.TaskId)
		return nil, fmt.Errorf("executable is empty")
	}
	log.Printf("Processing task %s with executable %s", taskData.TaskId, taskData.Executable)

	// Read input partition from HyDFS
	resp, _ := s.hydfsClient.SendRequest(client.Request{
		Operation: client.GET,
		HyDFSFile: taskData.SrcFile,
	})
	if resp.Status == "error" {
		return nil, fmt.Errorf("Failed to fetch partition: %s", resp.Message)
	}

	lines := strings.Split(resp.Message, "\n")
	transformedLines := processWithExecutable(taskData.Executable, lines)
	if len(transformedLines) == 0 {
		return nil, fmt.Errorf("No output generated by executable %s", taskData.Executable)
	}
	// Append results to HyDFS
	resp, _ = s.hydfsClient.SendRequest(client.Request{
		Operation: client.APPEND,
		HyDFSFile: taskData.DestFile,
		Content:   strings.Join(transformedLines, "\n"),
	})
	if resp.Status == "error" {
		return nil, fmt.Errorf("Failed to append results to %s: %s", taskData.DestFile, resp.Message)
	}

	// Log task completion
	log.Printf("Task %s processed successfully", taskData.TaskId)
	return &api.ExecutionResponse{Success: true, Message: "Task executed successfully."}, nil
}

// Acknowledge task
func (s *workerServer) AckTask(ctx context.Context, ackInfo *api.AckInfo) (*api.AckResponse, error) {
	log.Printf("ack received: taskID=%s, ack=%v", ackInfo.TaskId, ackInfo.Ack)
	return &api.AckResponse{
		Success: true,
		Message: "ack received.",
	}, nil
}

// Parse worker index
func parseWorkerIndex(workerIndex string) int {
	index, err := strconv.Atoi(workerIndex)
	if err != nil || index < 0 {
		log.Fatalf("Invalid WORKER_INDEX: must be a positive integer, got %s", workerIndex)
	}
	return index
}

func main() {
	hydfsClient := client.NewClient("fa24-cs425-0701.cs.illinois.edu:8080")
	defer hydfsClient.Close()

	// Get hostname to use as part of the WorkerID
	hostname, err := os.Hostname()
	if err != nil {
		log.Fatalf("Failed to get hostname: %v", err)
	}

	workerIndex := os.Getenv("WORKER_INDEX")
	if workerIndex == "" {
		workerIndex = "1"
	}

	workerID := fmt.Sprintf("%s-worker-%s", hostname, workerIndex)
	port := 50050 + parseWorkerIndex(workerIndex)

	workerAddress := fmt.Sprintf("%s:%d", hostname, port)
	if envAddress := os.Getenv("WORKER_ADDRESS"); envAddress != "" {
		workerAddress = envAddress
	}

	go func() {
		lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
		if err != nil {
			log.Fatalf("Failed to listen on port %d: %v", port, err)
		}
		s := grpc.NewServer()
		api.RegisterWorkerServiceServer(s, &workerServer{
			workerID:    workerID,
			hydfsClient: hydfsClient,
		})
		log.Printf("WorkerService Server %s running on %s", workerID, workerAddress)
		if err := s.Serve(lis); err != nil {
			log.Fatalf("Failed to serve worker service: %v", err)
		}
	}()

	// Connect to leader
	leaderAddress := os.Getenv("LEADER_ADDRESS")
	if leaderAddress == "" {
		leaderAddress = "fa24-cs425-0701.cs.illinois.edu:50051"
	}

	conn, err := grpc.Dial(leaderAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("Failed to connect to leader: %v", err)
	}
	defer conn.Close()

	client := api.NewLeaderServiceClient(conn)
	_, err = client.RegisterWorker(context.Background(), &api.WorkerInfo{
		WorkerId: workerID,
		Address:  workerAddress,
	})
	if err != nil {
		log.Fatalf("Worker registration failed: %v", err)
	}
	log.Printf("Worker %s registered with leader at %s", workerID, leaderAddress)

	// Send periodic heartbeats
	// go func() {
	// 	for {
	// 		_, err := client.ReportTaskStatus(context.Background(), &api.TaskStatus{
	// 			TaskId:    "heartbeat",
	// 			Status:    "alive",
	// 			WorkerId:  workerID,
	// 			Timestamp: time.Now().Unix(),
	// 		})
	// 		if err != nil {
	// 			log.Printf("Heartbeat error: %v", err)
	// 		}
	// 		time.Sleep(5 * time.Second)
	// 	}
	// }()

	// Block forever
	select {}
}
