// registers with the leader, send periodic heartbeats to leader
// waits for task assignments from leader
// on start for all vms except 1 (leader); go to this directory and run: go run main.go
package main

import (
	"context"
	"fmt"
	"log"
	"mp4/pkg/api"
	"mp4/pkg/hydfs/client"
	"net"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"sync"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"github.com/google/shlex"
)

type workerServer struct {
	api.UnimplementedWorkerServiceServer
	mu            sync.Mutex
	workerID      string
	hydfsClient *client.Client
	hydfsLogFile  string
}

// Process lines with a given executable
func processWithExecutable(executable string, lines []string) []string {
	if executable == "" {
		log.Printf("Error: Executable is empty.")
		return nil
	}

	input := strings.Join(lines, "\n")
	parts, err := shlex.Split(executable)
	if len(parts) == 0 {
		log.Printf("Error: Executable command is invalid: %s", executable)
		return nil
	}
	fmt.Printf("attempting to process with executable: %s\n", executable)
	cmd := exec.Command(parts[0], parts[1:]...)
	cmd.Stdin = strings.NewReader(input)

	output, err := cmd.Output()
	if err != nil {
		log.Printf("Error running %s: %v", executable, err)
		return nil
	}

	return strings.Split(strings.TrimSpace(string(output)), "\n")
}

// DISABLED FOR NOW
// func logState(hydfsClient *client.Client, taskID string, uids []string, results []string) error {
// 	logFile := fmt.Sprintf("task-%s-log", taskID)
// 	content := fmt.Sprintf("UIDs:%s\nResults:%s\n", strings.Join(uids, ","), strings.Join(results, "\n"))

// 	tempFile := "temp-" + logFile
// 	file, _ := os.Create(tempFile)
// 	file.WriteString(content)
// 	s.mu.Lock()
// 	resp = hydfsClient.AppendRequest(tempFile, logFile)
// 	// fmt.Printf("Logfile append: %s\n", logFile)
// 	s.mu.Unlock()
// 	os.Remove(tempFile)
// 	return nil
// }

func (s *workerServer) hydfsLog(content string) {
	tempFile, _ := os.CreateTemp("", "hydfs_log_*.tmp")
	defer tempFile.Close()
	_, _ = tempFile.WriteString(content + "\n")
	tempFileName := tempFile.Name()
	s.mu.Lock()
	_ = s.hydfsClient.AppendRequest(tempFileName, s.hydfsLogFile)
	s.mu.Unlock()
	_ = os.Remove(tempFileName)
}


// Handle task execution from leader
func (s *workerServer) ExecuteTask(ctx context.Context, taskData *api.TaskData) (*api.ExecutionResponse, error) {
	// worker log: recieved task
	s.hydfsLog(fmt.Sprintf("Recieved/Beginning task <%s> with executable <%s>", taskData.TaskId, taskData.Executable))

	if taskData.Executable == "" {
		log.Printf("Error: Executable is empty for task %s", taskData.TaskId)
		return nil, fmt.Errorf("executable is empty")
	}
	log.Printf("Processing task <%s> with executable <%s>", taskData.TaskId, taskData.Executable)

	// Read input partition from HyDFS
	srcFile := taskData.SrcFile
	localFile := "temp-" + taskData.SrcFile
	// Read input partition from HyDFS
	s.mu.Lock()
	resp := s.hydfsClient.GetRequest(srcFile, localFile)
	s.mu.Unlock()
	if resp == "error" {
		log.Fatalf("Input file download failed")
	}
	// Read the file content into memory
	fileContent, _ := os.ReadFile(localFile)
	os.Remove(localFile)

	// fmt.Printf("read file content from hydfs for task %s: %s\n", taskData.TaskId, fileContent)
	lines := strings.Split(string(fileContent), "\n")
	fmt.Printf("lines read from %s: %d\n", srcFile, len(lines))
	transformedLines := processWithExecutable(taskData.Executable, lines)
	if len(transformedLines) == 0 {
		return nil, fmt.Errorf("No output generated by executable %s", taskData.Executable)
	}
	fmt.Printf("# transformed lines for task %s: %d\n", taskData.TaskId, len(transformedLines))
	// Append results for next stage
	tempFile := "temp-" + taskData.DestFile
	file, _ := os.Create(tempFile)
	file.WriteString(strings.Join(transformedLines, "\n"))
	s.mu.Lock()
	fmt.Printf("attempting to create intermediate file %s\n", taskData.DestFile)
	s.hydfsClient.DeleteRequest(taskData.DestFile)
	resp = s.hydfsClient.CreateRequest(tempFile, taskData.DestFile)
	s.mu.Unlock()
	os.Remove(tempFile)
	if resp == "error" {
		return nil, fmt.Errorf("Failed to append results to %s\n", taskData.DestFile)
	}

	// Log task completion
	log.Printf("Task %s processed successfully", taskData.TaskId)
	// worker log: finished task
	s.hydfsLog(fmt.Sprintf("Finished task <%s> with executable <%s>", taskData.TaskId, taskData.Executable))

	return &api.ExecutionResponse{Success: true, Message: "Task executed successfully."}, nil
}

// Acknowledge task
func (s *workerServer) AckTask(ctx context.Context, ackInfo *api.AckInfo) (*api.AckResponse, error) {
	log.Printf("ack received: taskID=%s, ack=%v", ackInfo.TaskId, ackInfo.Ack)
	return &api.AckResponse{
		Success: true,
		Message: "ack received.",
	}, nil
}

// Parse worker index
func parseWorkerIndex(workerIndex string) int {
	index, err := strconv.Atoi(workerIndex)
	if err != nil || index < 0 {
		log.Fatalf("Invalid WORKER_INDEX: must be a positive integer, got %s", workerIndex)
	}
	return index
}

func main() {
	// cmd := exec.Command("scripts/filter.exe", "Punched Telespar")
	// lines := []string{
	// 	`-9822751.72354012,4887683.30017848,2,Streetname - Mast Arm,"16"" X 42""", ,Traffic Signal Mast Arm, ,Streetname, ,D3-1,Champaign,2,,AERIAL,L,N Market St,2.0,`,
	// 	`-9828662.01808626,4879483.90715145,3,No Outlet,"30"" X 30""", ,Punched Telespar,2010,Warning, ,W14-2,Champaign,3,,AERIAL,E,,3.0,`,
	// }
	// cmd.Stdin = strings.NewReader(strings.Join(lines, "\n"))
	// output, err := cmd.Output()
	// fmt.Printf("cmd output: %s\n", output)
	// return
	// transformedLines := processWithExecutable("./scripts/filter.exe \"Punched Telespar\"", lines)
	// fmt.Printf(strings.Join(transformedLines, "\n"))
	// return
	hydfsClient := client.NewClient("fa24-cs425-0701.cs.illinois.edu:8080")
	defer hydfsClient.Close()

	// Get hostname to use as part of the WorkerID
	hostname, err := os.Hostname()
	if err != nil {
		log.Fatalf("Failed to get hostname: %v", err)
	}

	workerIndex := os.Getenv("WORKER_INDEX")
	if workerIndex == "" {
		workerIndex = "1"
	}

	workerID := fmt.Sprintf("%s-worker-%s", hostname, workerIndex)
	port := 50050 + parseWorkerIndex(workerIndex)

	workerAddress := fmt.Sprintf("%s:%d", hostname, port)
	if envAddress := os.Getenv("WORKER_ADDRESS"); envAddress != "" {
		workerAddress = envAddress
	}

	go func() {
		lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
		if err != nil {
			log.Fatalf("Failed to listen on port %d: %v", port, err)
		}
		s := grpc.NewServer()
		api.RegisterWorkerServiceServer(s, &workerServer{
			workerID:    workerID,
			hydfsClient: hydfsClient,
			hydfsLogFile: "worker-" + workerIndex + ".log",
		})
		hydfsClient.DeleteRequest("worker-" + workerIndex + ".log")
		hydfsClient.CreateRequest("blank", "worker-" + workerIndex + ".log")
		log.Printf("WorkerService Server %s running on %s", workerID, workerAddress)
		if err := s.Serve(lis); err != nil {
			log.Fatalf("Failed to serve worker service: %v", err)
		}
	}()

	// Connect to leader
	leaderAddress := os.Getenv("LEADER_ADDRESS")
	if leaderAddress == "" {
		leaderAddress = "fa24-cs425-0701.cs.illinois.edu:50051"
	}

	conn, err := grpc.Dial(leaderAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("Failed to connect to leader: %v", err)
	}
	defer conn.Close()

	client := api.NewLeaderServiceClient(conn)
	_, err = client.RegisterWorker(context.Background(), &api.WorkerInfo{
		WorkerId: workerID,
		Address:  workerAddress,
	})
	if err != nil {
		log.Fatalf("Worker registration failed: %v", err)
	}
	log.Printf("Worker %s registered with leader at %s", workerID, leaderAddress)

	// Send periodic heartbeats
	// go func() {
	// 	for {
	// 		_, err := client.ReportTaskStatus(context.Background(), &api.TaskStatus{
	// 			TaskId:    "heartbeat",
	// 			Status:    "alive",
	// 			WorkerId:  workerID,
	// 			Timestamp: time.Now().Unix(),
	// 		})
	// 		if err != nil {
	// 			log.Printf("Heartbeat error: %v", err)
	// 		}
	// 		time.Sleep(5 * time.Second)
	// 	}
	// }()

	// Block forever
	select {}
}
